

# This file was *autogenerated* from the file matrix_utils.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_100 = Integer(100); _sage_const_10000 = Integer(10000); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0)
import itertools as itt

#---------------------------------------------------------------------
def vec_cden(v):
    ''' LCM of denominators of vector v coordinates'''
    return lcm([abs(fr.denominator()) for fr in v])

#---------------------------------------------------------------------
def vec_cnum(v):
    ''' GCD of numerators of vector v coordinates'''
    return gcd([abs(fr.numerator()) for fr in v])

#---------------------------------------------------------------------
def vec_cfactor(v):
    '''rational fraction a/b, such that coordinates of a/b*v are coprime and integral'''
    return vec_cden(v)/vec_cnum(v)

#---------------------------------------------------------------------
def mat_cfactor(mat):
    '''diagonal matrix D, such that D*mat has rows with all coordinates coprime and integral'''
    return diagonal_matrix(vec_cfactor(rw) for rw in mat.rows())

#---------------------------------------------------------------------
def mat_cden(M):
    ''' LCM of denominators of vector v coordinates'''
    return lcm([abs(fr).denominator() for rw in M.rows() for fr in rw])

#---------------------------------------------------------------------
def lt_part(M):
    '''Lower triangular part of a matrix M, without the principal  diagonal'''
    N = zero_matrix(M.base_ring(), M.nrows(), M.ncols())
    for i in range(M.nrows()):
        N[i,:i] = M[i,:i]
    return N

#---------------------------------------------------------------------
def ut_part(M):
    '''Upper triangular part of a matrix M, together with its principal diagonal'''
    N = zero_matrix(M.base_ring(), M.nrows(), M.ncols())
    for i in range(M.nrows()):
        N[i, i:] = M[i, i:]
    return N

#---------------------------------------------------------------------
def skew_up(M):
    '''Skew-symmetric matrix by reflection of the upper triangular part of M'''
    up = ut_part(M)
    return (up - up.transpose())

#---------------------------------------------------------------------
def skew_dwn(M):
    '''Skew-symmetric matrix by reflection of the lower triangular part of M'''
    dwn = lt_part(M)
    return(dwn - dwn.transpose())

#---------------------------------------------------------------------
def random_ltdet1_Zmatrix(ndim, max_height):
    ''' Returns square random lower triangular integer matrix of the size ndim x ndim  with entries in a given ring (=ZZ by default) of height at most max_height (=100 by default)  and all 1's on the principal diagonal'''
    return lt_part(random_matrix(ZZ, ndim, ndim, x=-max_height, y=max_height+_sage_const_1 ))+identity_matrix(ZZ, ndim)

#---------------------------------------------------------------------
def random_orthogonal_Qmatrix(ndim, max_height=_sage_const_100 , max_tries = _sage_const_10000 ):
    '''
        Attempts to generate random orthogonal ndim x ndim matrix with rational entries whose numerators and denominators does not exceed max_height (=10000 by default) and normalizes it so that main diagonal elementas are >= 0. If it does not succeed after max_tries (= 1000 by default) attempts, an exception is raised.
    ''' 
    #Limit the size of the search space so that the number of tries is within square root of (2*height(M)+1)^(n^2) 
    max_bound = _sage_const_3 *ceil((max_tries**(_sage_const_2 /(ndim**_sage_const_2 ))).n())

    if max_height < max_bound:
        max_bound = max_height
    
    for attempt in range(max_tries):
        M = random_matrix(QQ, ndim, ndim, num_bound = max_bound, den_bound = max_bound)
        E = identity_matrix(QQ, ndim)
        S = skew_up(M)
        T = (E+S).inverse()*(E-S)
        dsgn = [sign(el) for el in T.diagonal()]
        for n, it in enumerate(dsgn):
            if it == _sage_const_0 :
                dsgn[n] = _sage_const_1 
        D = diagonal_matrix(QQ, ndim, dsgn);        
        if T.height() < max_height:
            return D*T
    raise Exception('Number of tries exceeded!')

#---------------------------------------------------------------------
def random_orthogonal_Zmatrix(ndim, max_height=_sage_const_100 , max_tries = _sage_const_10000 ):
    '''
            Attempts to generate random orthogonal ndim x ndim matrix with integer entries not exceeding max_height (= 100 by default) in absolute value and normalizes it so that main diagonal elements are >= 0. If it does not succeed after max_tries (= 1000 by default) number of attempts, an exception is raised.
    '''
    M = random_orthogonal_Qmatrix(ndim, max_height, max_tries)
    return mat_cden(M)*M

#---------------------------------------------------------------------
def Pythagorean_tuples(mat):

    pt_tuples = set()
    
    for vec in mat.rows():
        pt = [abs(c) for c in vec] + [vec.dot_product(vec)]
        pt.sort()
        pt_tuples.add(tuple(pt))
        
    for vec in mat.columns():
        pt = [abs(c) for c in vec] + [vec.dot_product(vec)]
        pt.sort()
        pt_tuples.add(tuple(pt))

    return pt_tuples

#---------------------------------------------------------------------
def nice_GramSchmidtZ(mat):
    '''
        Produces matrices Q and L, such that L*Q = mat, rows of Q are orthogonal and integer, L is lower triangular and integral (if possible)  
    '''
    Q,L = mat.gram_schmidt()
	D = mat_cfactor(Q) #integralizing factor
	niceQ = D*Q
	niceL = L*D.inverse()

	return niceQ, niceL

#---------------------------------------------------------------------
def sort_matrix_rows(M, rev=False):
    '''
        Sorts matrix rows
    '''
    rw = M.rows()
    rw.sort(reverse=rev)
    
    return matrix(M.base_ring(), M.nrows(), M.ncols(), rw)

#---------------------------------------------------------------------
def sort_matrix_cols(M, rev=False):
    '''
        Sorts matrix columns
    '''
    cl = M.columns()
    cl.sort(reverse=rev)
    
    return matrix(M.base_ring(), M.ncols(), M.nrows(), cl).transpose()


#---------------------------------------------------------------------
def sort_matrix(M, rev=False):
    '''
        Sorts matrix by columns then by rows until it stabilizes or enters a cycle
    '''
    prev_mats = [M]

    while True:
        next_mat = sort_matrix_rows(sort_matrix_cols(prev_mats[-_sage_const_1 ], rev), rev)
        if next_mat in prev_mats:
            break
        prev_mats.append(next_mat)
        
    return next_mat
    
#---------------------------------------------------------------------
def colinear_vecs(u, v):
    ''' Checks if two vectors u and v  are colinear.'''
    A = matrix(ZZ, [u, v])
    if A.rank() == _sage_const_2 :
        return _sage_const_0 
    else:
        return _sage_const_1 

#---------------------------------------------------------------------
def colinear_rc(M):
    ''' Reports number r of colinear rows and number c of colinear columns in matrix M. '''
    return (sum(colinear_vecs(u, v) for u, v in itt.combinations(M.rows(),_sage_const_2 )), sum(colinear_vecs(u, v) for u, v in itt.combinations(M.columns(),_sage_const_2 )))

#---------------------------------------------------------------------
def zeros_rc(M):
    ''' Reports maximal numbers of zeros accross rows and columns of  matrix M.'''
    return (max([r.list().count(_sage_const_0 ) for r in M.rows()]), max([c.list().count(_sage_const_0 ) for c in M.columns()]))    

#---------------------------------------------------------------------
def ones_fc(M):
    ''' Reports number of 1 and -1 in the first column of matrix M '''
    return list(M.columns()[_sage_const_0 ]).count(_sage_const_1 )+list(M.columns()[_sage_const_0 ]).count(-_sage_const_1 )

#---------------------------------------------------------------------
def accept_matrix(M, allow_colinear = False, has_ones_fc = False, max_zeros = _sage_const_1 , max_height = _sage_const_10000 ):
    ''' Runs tests on matrix M: 
        a) If allow_colinear = False, checks if M has ay colinear rows or columns
        b) If has_ones = True, then checks if first column of M contains any 1 or -1
        c) Checks if matrix has no more than max_zeros in each row and column of M
        If all checks succeed, returns True, otherwise returns False.
     '''

    if not allow_colinear:
        if max(colinear_rc(M)) > _sage_const_0 :
            return False
     
    if has_ones_fc:
        if ones_fc(M) == _sage_const_0 :
            return False

    if max(zeros_rc(M)) > max_zeros:
        return False

    if M.height() > max_height:
        return False

    return True

